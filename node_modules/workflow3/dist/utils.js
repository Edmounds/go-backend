import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export function getMCPWorkingDirectory() {
    console.error('ğŸ” [workflow3] ===== è·å–MCPå·¥ä½œç›®å½•è¯Šæ–­å¼€å§‹ =====');
    console.error(`ğŸ” [workflow3] process.cwd(): ${process.cwd()}`);
    const workspacePaths = process.env.WORKSPACE_FOLDER_PATHS;
    console.error(`ğŸ” [workflow3] ç­–ç•¥1 - WORKSPACE_FOLDER_PATHS: ${workspacePaths || 'undefined'}`);
    if (workspacePaths) {
        try {
            const folders = JSON.parse(workspacePaths);
            if (Array.isArray(folders) && folders.length > 0) {
                const firstFolder = folders[0];
                if (isValidDirectory(firstFolder)) {
                    console.error(`ğŸ” [workflow3] ç­–ç•¥1æˆåŠŸ: ${firstFolder}`);
                    return firstFolder;
                }
            }
        }
        catch {
            const firstPath = workspacePaths.split(path.delimiter)[0];
            if (firstPath && isValidDirectory(firstPath)) {
                console.error(`ğŸ” [workflow3] ç­–ç•¥1å¤‡ç”¨æˆåŠŸ: ${firstPath}`);
                return firstPath;
            }
        }
    }
    const ideEnvVars = [
        'VSCODE_WORKSPACE_FOLDER',
        'VSCODE_CWD',
        'PROJECT_ROOT',
        'IDEA_INITIAL_DIRECTORY',
        'WEBSTORM_PROJECT_PATH'
    ];
    for (const envVar of ideEnvVars) {
        const envValue = process.env[envVar];
        console.error(`ğŸ” [workflow3] ç­–ç•¥2 - ${envVar}: ${envValue || 'undefined'}`);
        if (envValue && isValidDirectory(envValue)) {
            console.error(`ğŸ” [workflow3] ç­–ç•¥2æˆåŠŸ: ${envValue}`);
            return envValue;
        }
    }
    const pwd = process.env.PWD;
    console.error(`ğŸ” [workflow3] ç­–ç•¥3 - PWD: ${pwd || 'undefined'}`);
    if (pwd && isValidDirectory(pwd) && pwd !== process.cwd()) {
        console.error(`ğŸ” [workflow3] ç­–ç•¥3æˆåŠŸ: ${pwd}`);
        return pwd;
    }
    const projectRoot = findProjectRoot(process.cwd());
    console.error(`ğŸ” [workflow3] ç­–ç•¥4ç»“æœ: ${projectRoot || 'null'}`);
    if (projectRoot && projectRoot !== process.cwd()) {
        console.error(`ğŸ” [workflow3] ç­–ç•¥4æˆåŠŸ: ${projectRoot}`);
        return projectRoot;
    }
    const fallbackPath = process.cwd();
    console.error(`ğŸ” [workflow3] ç­–ç•¥5 - å›é€€åˆ°process.cwd(): ${fallbackPath}`);
    console.error('ğŸ” [workflow3] ===== è·å–MCPå·¥ä½œç›®å½•è¯Šæ–­ç»“æŸ =====');
    return fallbackPath;
}
function isValidDirectory(dir) {
    try {
        if (!dir || typeof dir !== 'string') {
            return false;
        }
        const resolvedDir = path.resolve(dir);
        const stat = fs.statSync(resolvedDir);
        return stat.isDirectory();
    }
    catch {
        return false;
    }
}
export function findProjectRoot(startDir = process.cwd()) {
    const projectMarkers = [
        'package.json',
        '.git',
        'yarn.lock',
        'pnpm-lock.yaml',
        'composer.json',
        'Cargo.toml',
        'go.mod',
        'pyproject.toml',
        'requirements.txt'
    ];
    let currentDir = path.resolve(startDir);
    const rootDir = path.parse(currentDir).root;
    while (currentDir !== rootDir) {
        const hasProjectMarker = projectMarkers.some(marker => {
            const markerPath = path.join(currentDir, marker);
            return fs.existsSync(markerPath);
        });
        if (hasProjectMarker) {
            return currentDir;
        }
        currentDir = path.dirname(currentDir);
    }
    return startDir;
}
export function getTemplateFilePath() {
    return path.join(__dirname, 'templates', 'workflow3.md');
}
export function readTemplateContent() {
    const templatePath = getTemplateFilePath();
    if (!fs.existsSync(templatePath)) {
        throw new Error(`Template file not found: ${templatePath}`);
    }
    return fs.readFileSync(templatePath, 'utf-8');
}
export function getOrCreateWorkflowFile() {
    try {
        const workflowFilePath = path.join(os.homedir(), '.workflow3.md');
        console.error(`ğŸ” [workflow3] ç›®æ ‡æ–‡ä»¶è·¯å¾„: ${workflowFilePath}`);
        handleLegacyWorkflowFile();
        if (fs.existsSync(workflowFilePath)) {
            console.error(`âœ… [workflow3] è¯»å–ç°æœ‰æ–‡ä»¶: ${workflowFilePath}`);
            return fs.readFileSync(workflowFilePath, 'utf-8');
        }
        else {
            console.error(`ğŸ“ [workflow3] åˆ›å»ºæ–°æ–‡ä»¶: ${workflowFilePath}`);
            const defaultContent = readTemplateContent();
            fs.writeFileSync(workflowFilePath, defaultContent, 'utf-8');
            console.error(`âœ… [workflow3] æ–‡ä»¶åˆ›å»ºæˆåŠŸ: ${workflowFilePath}`);
            return defaultContent;
        }
    }
    catch (error) {
        console.error(`âŒ [workflow3] æ–‡ä»¶æ“ä½œå¤±è´¥: ${error}`);
        console.error('ğŸ”„ [workflow3] ä½¿ç”¨æ¨¡æ¿å†…å®¹ä½œä¸ºfallback');
        return readTemplateContent();
    }
}
function handleLegacyWorkflowFile() {
    try {
        const projectRoot = getMCPWorkingDirectory();
        const legacyFilePath = path.join(projectRoot, 'workflow3.md');
        if (fs.existsSync(legacyFilePath)) {
            const content = fs.readFileSync(legacyFilePath, 'utf-8');
            if (content.includes('æœ¬æ–‡ä»¶å·²å¤±æ•ˆ')) {
                return;
            }
            const deprecationNotice = `# æ³¨æ„ï¼šæœ¬æ–‡ä»¶å·²å¤±æ•ˆ

æœ¬æ–‡ä»¶å·²å¤±æ•ˆï¼Œæœ‰æ•ˆçš„æ–‡ä»¶è·¯å¾„å·²æ›´æ”¹åˆ° ~/.workflow3.md

è¯·åˆ é™¤æ­¤æ–‡ä»¶ï¼Œå¹¶åœ¨ç”¨æˆ·ä¸»ç›®å½•çš„ ~/.workflow3.md æ–‡ä»¶ä¸­è¿›è¡Œé…ç½®ã€‚

---

`;
            const updatedContent = deprecationNotice + content;
            fs.writeFileSync(legacyFilePath, updatedContent, 'utf-8');
            console.error(`ğŸ“ [workflow3] å·²åœ¨æ—§æ–‡ä»¶æ·»åŠ å¤±æ•ˆè¯´æ˜: ${legacyFilePath}`);
        }
    }
    catch (error) {
        console.error(`âš ï¸ [workflow3] å¤„ç†æ—§æ–‡ä»¶æ—¶å‡ºé”™: ${error}`);
    }
}
//# sourceMappingURL=utils.js.map